---
title: 同步基元概述
description: 了解用于同步对共享资源或控制线程交互的访问的 .NET 线程同步基元
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: d5ae0fe5813952742950582a4282cd1c6ab6a870
ms.sourcegitcommit: 7588b1f16b7608bc6833c05f91ae670c22ef56f8
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/02/2020
ms.locfileid: "93188973"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="9f1e5-103">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="9f1e5-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="9f1e5-104">.NET 提供了一系列可用于同步对共享资源或协调线程交互的访问的类型。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9f1e5-105">使用相同的同步基元实例保护对共享资源的访问。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="9f1e5-106">如果使用不同的同步基元实例保护同一资源，则将避开同步基元提供的保护。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="9f1e5-107">WaitHandle 类和轻量同步类型</span><span class="sxs-lookup"><span data-stu-id="9f1e5-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="9f1e5-108">多个 .NET 同步基元派生自 <xref:System.Threading.WaitHandle?displayProperty=nameWithType> 类，该类会封装本机操作系统同步句柄并将信号机制用于线程交互。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="9f1e5-109">这些类包括：</span><span class="sxs-lookup"><span data-stu-id="9f1e5-109">Those classes include:</span></span>

- <span data-ttu-id="9f1e5-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>，授予对共享资源的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="9f1e5-111">如果没有任何线程拥有它，则 mutex 将处于已发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="9f1e5-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>，限制可同时访问某一共享资源或资源池的线程数。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="9f1e5-113">当信号量计数大于零时，会将信号量的状态设置为已发出信号；当信号量计数为零时，会将信号量的状态设置为未发出信号。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="9f1e5-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>，表示线程同步事件，可以处于已发出信号状态或未发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="9f1e5-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>，派生自 <xref:System.Threading.EventWaitHandle>，当发出信号时，会在发布单个等待线程后自动重置为未发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="9f1e5-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>，派生自 <xref:System.Threading.EventWaitHandle>，当发出信号时，会保持已发出信号状态，直到调用 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="9f1e5-117">在 .NET Framework 中，由于 <xref:System.Threading.WaitHandle> 派生自 <xref:System.MarshalByRefObject?displayProperty=nameWithType>，因此，这些类型可用于跨应用程序域边界同步线程的活动。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-117">In .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="9f1e5-118">在 .NET Framework、.NET Core 和 .NET 5+ 中，其中的一些类型可以表示已命名的系统同步句柄，这些句柄在整个操作系统中都可见并可用于进程间同步：</span><span class="sxs-lookup"><span data-stu-id="9f1e5-118">In .NET Framework, .NET Core, and .NET 5+, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <xref:System.Threading.Mutex>
- <span data-ttu-id="9f1e5-119"><xref:System.Threading.Semaphore>（在 Windows 上）</span><span class="sxs-lookup"><span data-stu-id="9f1e5-119"><xref:System.Threading.Semaphore> (on Windows)</span></span>
- <span data-ttu-id="9f1e5-120"><xref:System.Threading.EventWaitHandle>（在 Windows 上）</span><span class="sxs-lookup"><span data-stu-id="9f1e5-120"><xref:System.Threading.EventWaitHandle> (on Windows)</span></span>

<span data-ttu-id="9f1e5-121">有关详细信息，请参阅 <xref:System.Threading.WaitHandle> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-121">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="9f1e5-122">轻量同步类型不依赖于基础操作系统句柄，通常会提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-122">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="9f1e5-123">但是，它们不能用于进程间同步。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-123">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="9f1e5-124">将这些类型用于一个应用程序中的线程同步。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-124">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="9f1e5-125">其中的一些类型是派生自 <xref:System.Threading.WaitHandle> 的类型的替代项。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-125">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="9f1e5-126">例如，<xref:System.Threading.SemaphoreSlim> 是 <xref:System.Threading.Semaphore> 的轻量替代项。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-126">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="9f1e5-127">同步对共享资源的访问</span><span class="sxs-lookup"><span data-stu-id="9f1e5-127">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="9f1e5-128">.NET 提供了一系列用于控制多个线程对共享资源的访问的同步基元。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-128">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="9f1e5-129">Monitor 类</span><span class="sxs-lookup"><span data-stu-id="9f1e5-129">Monitor class</span></span>

<span data-ttu-id="9f1e5-130"><xref:System.Threading.Monitor?displayProperty=nameWithType> 类通过获取或释放用于标识资源的对象上的 lock 来授予对共享资源的相互独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-130">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="9f1e5-131">持有 lock 时，持有 lock 的线程可以再次获取并释放 lock。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-131">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="9f1e5-132">阻止任何其他线程获取 lock，<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法等待释放 lock。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-132">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="9f1e5-133"><xref:System.Threading.Monitor.Enter%2A> 方法可获取释放的 lock。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-133">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="9f1e5-134">还可以使用 <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> 方法指定线程尝试获取 lock 的持续时间。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-134">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="9f1e5-135">由于 <xref:System.Threading.Monitor> 类具有线程关联，因此获取了 lock 的线程必须通过调用 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法来释放 lock。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-135">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="9f1e5-136">可以通过使用 <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 方法来协调用于获取同一对象上的 lock 的线程的交互。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-136">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="9f1e5-137">有关详细信息，请参阅 <xref:System.Threading.Monitor> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-137">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="9f1e5-138">使用 C# 中的 [lock](../../csharp/language-reference/keywords/lock-statement.md) 语句和 Visual Basic 中的 [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) 语句同步对共享资源的访问，而不是直接使用 <xref:System.Threading.Monitor> 类。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-138">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="9f1e5-139">这些语句是使用 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A> 方法进行实现，并使用 `try…finally` 块来确保获取的 lock 已始终释放。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-139">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="9f1e5-140">Mutex 类</span><span class="sxs-lookup"><span data-stu-id="9f1e5-140">Mutex class</span></span>

<span data-ttu-id="9f1e5-141"><xref:System.Threading.Mutex?displayProperty=nameWithType> 类（与 <xref:System.Threading.Monitor> 类似），授予对共享资源的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-141">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="9f1e5-142">使用 [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) 方法重载之一请求 mutex 的所有权。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-142">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="9f1e5-143"><xref:System.Threading.Mutex>（与 <xref:System.Threading.Monitor> 类似）具有线程关联，并且已获取 mutex 的线程必须通过调用 <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> 方法来释放它。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-143">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="9f1e5-144"><xref:System.Threading.Mutex> 类（与 <xref:System.Threading.Monitor> 不同）可用于进程间同步。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-144">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="9f1e5-145">为此，请使用命名 mutex，它在整个操作系统中都可见。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-145">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="9f1e5-146">若要创建命名 mutex 实例，请使用指定了名称的 [Mutex 构造函数](<xref:System.Threading.Mutex.%23ctor%2A>)。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-146">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="9f1e5-147">还可以调用 <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> 方法来打开现有的命名系统 mutex。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-147">You can also call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="9f1e5-148">有关详细信息，请参阅 [Mutex](mutexes.md) 一文和 <xref:System.Threading.Mutex> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-148">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="9f1e5-149">SpinLock 结构</span><span class="sxs-lookup"><span data-stu-id="9f1e5-149">SpinLock structure</span></span>

<span data-ttu-id="9f1e5-150"><xref:System.Threading.SpinLock?displayProperty=nameWithType> 结构（类似于 <xref:System.Threading.Monitor>），基于 lock 的可用性授予对共享资源的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-150">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="9f1e5-151">当 <xref:System.Threading.SpinLock> 尝试获取不可用的 lock 时，将在反复检查的循环中等待，直到 lock 变为可用。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-151">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="9f1e5-152">有关使用 SpinLock 的优缺点的详细信息，请参阅 [SpinLock](spinlock.md) 一文和 <xref:System.Threading.SpinLock> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-152">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="9f1e5-153">ReaderWriterLockSlim 类</span><span class="sxs-lookup"><span data-stu-id="9f1e5-153">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="9f1e5-154"><xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> 类授予对共享资源的独占访问权限以便进行写入，并允许多个线程同时访问资源以便进行读取。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-154">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="9f1e5-155">你可能想要使用 <xref:System.Threading.ReaderWriterLockSlim> 同步对支持线程安全读取操作，但需要独占访问权限才能执行写入操作的共享数据结构的访问。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-155">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="9f1e5-156">当某个线程请求独占访问时（例如，通过调用 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> 方法），后续读取器和编写器请求将被阻止，直到所有现有读取器均已退出 lock，并且编写器已进入并退出 lock。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-156">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="9f1e5-157">有关详细信息，请参阅 <xref:System.Threading.ReaderWriterLockSlim> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-157">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="9f1e5-158">Semaphore 和 SemaphoreSlim 类</span><span class="sxs-lookup"><span data-stu-id="9f1e5-158">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="9f1e5-159"><xref:System.Threading.Semaphore?displayProperty=nameWithType> 和 <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> 限制可同时访问某一共享资源或资源池的线程数。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-159">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="9f1e5-160">请求资源的其他线程将等待，直到任何线程释放信号量。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-160">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="9f1e5-161">由于信号量没有线程关联，因此一个线程可以获取信号量，而另一个线程可以释放它。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-161">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="9f1e5-162"><xref:System.Threading.SemaphoreSlim> 是 <xref:System.Threading.Semaphore> 的轻量替代项，并且只能在单个流程边界内用于同步。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-162"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="9f1e5-163">在 Windows 上，可以将 <xref:System.Threading.Semaphore> 用于进程间同步。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-163">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="9f1e5-164">为此，通过使用指定了名称或 <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> 方法的 [Semaphore 构造函数](<xref:System.Threading.Semaphore.%23ctor%2A>)之一来创建表示指定了已命名系统信号量的 <xref:System.Threading.Semaphore> 实例。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-164">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9f1e5-165"><xref:System.Threading.SemaphoreSlim> 不支持已命名系统信号量。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-165"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="9f1e5-166">有关详细信息，请参阅 [Semaphore 和 SemaphoreSlim](semaphore-and-semaphoreslim.md) 一文以及 <xref:System.Threading.Semaphore> 或 <xref:System.Threading.SemaphoreSlim> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-166">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="9f1e5-167">线程交互或信号</span><span class="sxs-lookup"><span data-stu-id="9f1e5-167">Thread interaction, or signaling</span></span>

<span data-ttu-id="9f1e5-168">线程交互（或线程信号）表示线程必须等待来自一个或多个线程的通知或信号才能继续。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-168">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="9f1e5-169">例如，如果线程 A 调用线程 B 的 <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> 方法，则线程 A 将被阻止，直到完成线程 B。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-169">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="9f1e5-170">前面部分中所述的同步基元提供不同的信号机制：通过释放 lock，一个线程通知另一个线程可以通过获取 lock 来继续。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-170">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="9f1e5-171">本部分介绍 .NET 提供的其他信号构造。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-171">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="9f1e5-172">EventWaitHandle、AutoResetEvent、ManualResetEvent 和 ManualResetEventSlim 类</span><span class="sxs-lookup"><span data-stu-id="9f1e5-172">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="9f1e5-173"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> 类表示一个线程同步事件。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-173">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="9f1e5-174">同步事件可以处于未发出信号状态或已发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-174">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="9f1e5-175">当事件的状态为未发出信号时，调用了事件的 <xref:System.Threading.WaitHandle.WaitOne%2A?> 重载的线程会被阻止，直到事件处于已发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-175">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="9f1e5-176"><xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 方法可将事件的状态设置为已发出信号。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-176">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="9f1e5-177">已发出信号的 <xref:System.Threading.EventWaitHandle> 的行为取决于其重置模式：</span><span class="sxs-lookup"><span data-stu-id="9f1e5-177">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="9f1e5-178">使用 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 标志创建的 <xref:System.Threading.EventWaitHandle> 会在释放单个等待线程后自动进行重置。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-178">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="9f1e5-179">就像旋转栅在每次发出信号时仅允许一个线程通过一样。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-179">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="9f1e5-180">派生自 <xref:System.Threading.EventWaitHandle> 的 <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> 类表示该行为。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-180">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="9f1e5-181">在 <xref:System.Threading.EventWaitHandle.Reset%2A> 方法获得调用前，一直向使用 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 标志创建的 <xref:System.Threading.EventWaitHandle> 发出信号。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-181">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="9f1e5-182">就像接收到信号前保持关闭、然后在被关闭前保持打开的大门一样。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-182">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="9f1e5-183">派生自 <xref:System.Threading.EventWaitHandle> 的 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 类表示该行为。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-183">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="9f1e5-184"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 类是 <xref:System.Threading.ManualResetEvent> 的轻量替代项。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-184">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="9f1e5-185">在 Windows 上，可以将 <xref:System.Threading.EventWaitHandle> 用于进程间同步。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-185">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="9f1e5-186">为此，通过使用指定了名称或 <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> 方法的 [EventWaitHandle 构造函数](<xref:System.Threading.EventWaitHandle.%23ctor%2A>)之一来创建表示指定了已命名系统信号量的 <xref:System.Threading.EventWaitHandle> 实例。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-186">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="9f1e5-187">有关详细信息，请参阅文章 [EventWaitHandle](eventwaithandle.md)。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-187">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="9f1e5-188">对于 API 参考，请参阅 <xref:System.Threading.EventWaitHandle>、<xref:System.Threading.AutoResetEvent>、<xref:System.Threading.ManualResetEvent> 和 <xref:System.Threading.ManualResetEventSlim>。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-188">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="9f1e5-189">CountdownEvent 类</span><span class="sxs-lookup"><span data-stu-id="9f1e5-189">CountdownEvent class</span></span>

<span data-ttu-id="9f1e5-190"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> 类表示当其计数为零时将被设置的事件。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-190">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="9f1e5-191">当 <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> 大于零时，调用了 <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> 的线程会被阻止。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-191">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="9f1e5-192">调用 <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> 会递减事件的计数。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-192">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="9f1e5-193">与可用于通过来自一个线程的信号取消阻止多个线程的 <xref:System.Threading.ManualResetEvent> 或 <xref:System.Threading.ManualResetEventSlim> 相反，你可以使用 <xref:System.Threading.CountdownEvent> 通过来自多个线程的信号取消阻止一个或多个线程。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-193">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="9f1e5-194">有关详细信息，请参阅 [CountdownEvent](countdownevent.md) 一文和 <xref:System.Threading.CountdownEvent> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-194">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="9f1e5-195">Barrier 类</span><span class="sxs-lookup"><span data-stu-id="9f1e5-195">Barrier class</span></span>

<span data-ttu-id="9f1e5-196"><xref:System.Threading.Barrier?displayProperty=nameWithType> 类表示线程执行屏障。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-196">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="9f1e5-197">调用了 <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> 方法的线程发出信号，它已到达屏障并等待其他参与线程到达屏障。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-197">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="9f1e5-198">当所有参与线程到达屏障时，它们将继续前进，屏障将进行重置，使之再次可用。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-198">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="9f1e5-199">在继续执行下一个计算阶段之前，当一个或多个线程需要其他线程的结果时，可以使用 <xref:System.Threading.Barrier>。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-199">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="9f1e5-200">有关详细信息，请参阅 [Barrier](barrier.md) 一文和 <xref:System.Threading.Barrier> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-200">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="9f1e5-201">Interlocked 类</span><span class="sxs-lookup"><span data-stu-id="9f1e5-201">Interlocked class</span></span>

<span data-ttu-id="9f1e5-202"><xref:System.Threading.Interlocked?displayProperty=nameWithType> 类提供了可对变量执行简单原子操作的静态方法。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-202">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="9f1e5-203">这些原子操作包括添加、递增和递减、交换、取决于比较的条件交换以及读取 64 位整数值的操作。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-203">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="9f1e5-204">有关详细信息，请参阅 <xref:System.Threading.Interlocked> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-204">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="9f1e5-205">SpinWait 结构</span><span class="sxs-lookup"><span data-stu-id="9f1e5-205">SpinWait structure</span></span>

<span data-ttu-id="9f1e5-206"><xref:System.Threading.SpinWait?displayProperty=nameWithType> 结构为基于自旋的等待提供支持。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-206">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="9f1e5-207">如果线程必须等待事件收到信号或必须满足某种条件，但实际等待时间应短于使用等待句柄或以其他方式阻止线程所需的等待时间，你可能想要使用该结构。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-207">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="9f1e5-208">通过使用 <xref:System.Threading.SpinWait>，你可以指定等待期间要旋转的一小段时间，且只在特定时间不满足条件时让行（例如，通过等待或休眠）。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-208">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="9f1e5-209">有关详细信息，请参阅 [SpinWait](spinwait.md) 一文和 <xref:System.Threading.SpinWait> API 参考。</span><span class="sxs-lookup"><span data-stu-id="9f1e5-209">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="9f1e5-210">请参阅</span><span class="sxs-lookup"><span data-stu-id="9f1e5-210">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="9f1e5-211">线程安全集合</span><span class="sxs-lookup"><span data-stu-id="9f1e5-211">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="9f1e5-212">线程处理对象和功能</span><span class="sxs-lookup"><span data-stu-id="9f1e5-212">Threading objects and features</span></span>](threading-objects-and-features.md)
