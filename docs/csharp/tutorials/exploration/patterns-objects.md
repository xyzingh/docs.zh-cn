---
title: 在对象中使用模式 - C# 教程
description: 本教程介绍了在类成员中使用模式匹配创建更好的对象行为模型的技巧
ms.date: 11/05/2020
ms.openlocfilehash: 072f6f57696504c2d691473e3a43c1cda53f227f
ms.sourcegitcommit: 6bef8abde346c59771a35f4f76bf037ff61c5ba3
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/06/2020
ms.locfileid: "94332172"
---
# <a name="use-pattern-matching-to-build-your-class-behavior-for-better-code"></a><span data-ttu-id="309a7-103">使用模式匹配生成类行为以获得更好的代码</span><span class="sxs-lookup"><span data-stu-id="309a7-103">Use pattern matching to build your class behavior for better code</span></span>

<span data-ttu-id="309a7-104">C# 中的模式匹配功能可提供语法来表示你的算法。</span><span class="sxs-lookup"><span data-stu-id="309a7-104">The pattern matching features in C# provide syntax to express your algorithms.</span></span> <span data-ttu-id="309a7-105">可以使用这些技巧来实现类中的行为。</span><span class="sxs-lookup"><span data-stu-id="309a7-105">You can use these techniques to implement the behavior in your classes.</span></span> <span data-ttu-id="309a7-106">在为真正的对象建模时，可以结合使用面向对象的类设计与面向数据的实现，来提供简洁的代码。</span><span class="sxs-lookup"><span data-stu-id="309a7-106">You can combine object-oriented class design with a data-oriented implementation to provide concise code while modeling real-world objects.</span></span>

<span data-ttu-id="309a7-107">本教程介绍以下操作：</span><span class="sxs-lookup"><span data-stu-id="309a7-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="309a7-108">使用数据模式表示面向对象的类。</span><span class="sxs-lookup"><span data-stu-id="309a7-108">Express your object oriented classes using data patterns.</span></span>
> - <span data-ttu-id="309a7-109">使用 C# 的模式匹配功能实现这些模式。</span><span class="sxs-lookup"><span data-stu-id="309a7-109">Implement those patterns using C#'s pattern matching features.</span></span>
> - <span data-ttu-id="309a7-110">利用编译器诊断来验证实现。</span><span class="sxs-lookup"><span data-stu-id="309a7-110">Leverage compiler diagnostics to validate your implementation.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="309a7-111">先决条件</span><span class="sxs-lookup"><span data-stu-id="309a7-111">Prerequisites</span></span>

<span data-ttu-id="309a7-112">需要将计算机设置为运行 .NET 5，包括 C# 9.0 编译器。</span><span class="sxs-lookup"><span data-stu-id="309a7-112">You’ll need to set up your machine to run .NET 5, including the C# 9.0 compiler.</span></span> <span data-ttu-id="309a7-113">自 [Visual Studio 2019 版本 16.8 预览版](https://visualstudio.microsoft.com/vs/preview/)或 [.NET 5.0 SDK 预览版](https://dotnet.microsoft.com/download/dotnet/5.0) 起，开始随附 C# 9.0 编译器。</span><span class="sxs-lookup"><span data-stu-id="309a7-113">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8 preview](https://visualstudio.microsoft.com/vs/preview/) or the [.NET 5.0 SDK preview](https://dotnet.microsoft.com/download/dotnet/5.0).</span></span>

## <a name="build-a-simulation-of-a-canal-lock"></a><span data-ttu-id="309a7-114">生成对运河闸的模拟</span><span class="sxs-lookup"><span data-stu-id="309a7-114">Build a simulation of a canal lock</span></span>

<span data-ttu-id="309a7-115">本教程将生成一个 C# 类，用于模拟[运河闸](https://en.wikipedia.org/wiki/Lock_(water_navigation))。</span><span class="sxs-lookup"><span data-stu-id="309a7-115">In this tutorial, you'll build a C# class that simulates a [canal lock](https://en.wikipedia.org/wiki/Lock_(water_navigation)).</span></span> <span data-ttu-id="309a7-116">简而言之，运河闸是指船只在两片不同水位的水域间穿行时用于升降它们的设施。</span><span class="sxs-lookup"><span data-stu-id="309a7-116">Briefly, a canal lock is a device that raises and lowers boats as they travel between two stretches of water at different levels.</span></span> <span data-ttu-id="309a7-117">一个闸有两个闸门和某种用来更改水位的机制。</span><span class="sxs-lookup"><span data-stu-id="309a7-117">A lock has two gates and some mechanism to change the water level.</span></span>

<span data-ttu-id="309a7-118">在闸正常运转的情况下，闸内的水位与船只驶入侧的水位一致时，船只会进入其中的一个闸门。</span><span class="sxs-lookup"><span data-stu-id="309a7-118">In its normal operation, a boat enters one of the gates while the water level in the lock matches the water level on the side the boat enters.</span></span> <span data-ttu-id="309a7-119">进入闸内后，水位将发生变化，以与船只驶离闸时所处的水位一致。</span><span class="sxs-lookup"><span data-stu-id="309a7-119">Once in the lock, the water level is changed to match the water level where the boat will leave the lock.</span></span> <span data-ttu-id="309a7-120">水位与驶离侧水位一致后，该侧的闸门将打开。</span><span class="sxs-lookup"><span data-stu-id="309a7-120">Once the water level matches that side, the gate on the exit side opens.</span></span> <span data-ttu-id="309a7-121">通过采用安全措施，可以确保操作人员不会在运河中引发危险情况。</span><span class="sxs-lookup"><span data-stu-id="309a7-121">Safety measures make sure an operator can't create a dangerous situation in the canal.</span></span> <span data-ttu-id="309a7-122">只有两个闸门都关闭时，水位才能发生变化。</span><span class="sxs-lookup"><span data-stu-id="309a7-122">The water level can be changed only when both gates are closed.</span></span> <span data-ttu-id="309a7-123">最多只能打开一个闸门。</span><span class="sxs-lookup"><span data-stu-id="309a7-123">At most one gate can be open.</span></span> <span data-ttu-id="309a7-124">闸内的水位必须与即将打开的闸门外部的水位一致，才能打开该闸门。</span><span class="sxs-lookup"><span data-stu-id="309a7-124">To open a gate, the water level in the lock must match the water level outside the gate being opened.</span></span>

<span data-ttu-id="309a7-125">可以生成 C# 类来为此行为建模。</span><span class="sxs-lookup"><span data-stu-id="309a7-125">You can build a C# class to model this behavior.</span></span> <span data-ttu-id="309a7-126">`CanalLock` 类将支持用于打开或关闭任意一个闸门的命令。</span><span class="sxs-lookup"><span data-stu-id="309a7-126">A `CanalLock` class would support commands to open or close either gate.</span></span> <span data-ttu-id="309a7-127">它还会包含其他用于升高或降低水位的命令。</span><span class="sxs-lookup"><span data-stu-id="309a7-127">It would have other commands to raise or lower the water.</span></span> <span data-ttu-id="309a7-128">此类还应支持用于读取两个闸门和水位当前状态的属性。</span><span class="sxs-lookup"><span data-stu-id="309a7-128">The class should also support properties to read the current state of both gates and the water level.</span></span> <span data-ttu-id="309a7-129">将通过方法实现安全措施。</span><span class="sxs-lookup"><span data-stu-id="309a7-129">Your methods implement the safety measures.</span></span>

## <a name="define-a-class"></a><span data-ttu-id="309a7-130">定义类</span><span class="sxs-lookup"><span data-stu-id="309a7-130">Define a class</span></span>

<span data-ttu-id="309a7-131">将生成一个控制台应用程序，用于测试 `CanalLock` 类。</span><span class="sxs-lookup"><span data-stu-id="309a7-131">You'll build a console application to test your `CanalLock` class.</span></span> <span data-ttu-id="309a7-132">使用 Visual Studio 或 .NET CLI 创建新的 .NET 5 控制台项目。</span><span class="sxs-lookup"><span data-stu-id="309a7-132">Create a new console project for .NET 5 using either Visual Studio or the .NET CLI.</span></span> <span data-ttu-id="309a7-133">然后，添加一个新类并将其命名为 `CanalLock`。</span><span class="sxs-lookup"><span data-stu-id="309a7-133">Then, add a new class and name it `CanalLock`.</span></span> <span data-ttu-id="309a7-134">接下来，设计公共 API，但不要实现方法：</span><span class="sxs-lookup"><span data-stu-id="309a7-134">Next, design your public API, but leave the methods not implemented:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="APIDesign":::

<span data-ttu-id="309a7-135">前面的代码会初始化对象，以便两个闸门都处于关闭状态，并且水位较低。</span><span class="sxs-lookup"><span data-stu-id="309a7-135">The preceding code initializes the object so both gates are closed, and the water level is low.</span></span> <span data-ttu-id="309a7-136">接下来，在 `Main` 方法中编写以下测试代码，以在你生成此类的第一个实现时引导你完成操作：</span><span class="sxs-lookup"><span data-stu-id="309a7-136">Next, write the following test code in your `Main` method to guide you as you create a first implementation of the class:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HappyTests":::

<span data-ttu-id="309a7-137">接下来，添加 `CanalLock` 类中每个方法的第一个实现。</span><span class="sxs-lookup"><span data-stu-id="309a7-137">Next, add a first implementation of each method in the `CanalLock` class.</span></span> <span data-ttu-id="309a7-138">以下代码将实现类的方法，你无需担心安全规则。</span><span class="sxs-lookup"><span data-stu-id="309a7-138">The following code implements the methods of the class without concern to the safety rules.</span></span> <span data-ttu-id="309a7-139">稍后将添加安全测试：</span><span class="sxs-lookup"><span data-stu-id="309a7-139">You'll add safety tests later:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="FirstImplementation":::

<span data-ttu-id="309a7-140">目前已编写的测试通过。</span><span class="sxs-lookup"><span data-stu-id="309a7-140">The tests you've written so far pass.</span></span> <span data-ttu-id="309a7-141">你已实现基本内容。</span><span class="sxs-lookup"><span data-stu-id="309a7-141">You've implemented the basics.</span></span> <span data-ttu-id="309a7-142">现在，针对第一种故障条件编写测试。</span><span class="sxs-lookup"><span data-stu-id="309a7-142">Now, write a test for the first failure condition.</span></span> <span data-ttu-id="309a7-143">前面的测试结束时，两个闸门都已关闭，并且水位设置为较低。</span><span class="sxs-lookup"><span data-stu-id="309a7-143">At the end of the previous tests, both gates are closed, and the water level is set to low.</span></span> <span data-ttu-id="309a7-144">添加一个测试，用于尝试打开上闸门：</span><span class="sxs-lookup"><span data-stu-id="309a7-144">Add a test to try opening the upper gate:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HighGateSafetyTest":::

<span data-ttu-id="309a7-145">此测试失败，因为该闸门打开了。</span><span class="sxs-lookup"><span data-stu-id="309a7-145">This test fails because the gate opens.</span></span> <span data-ttu-id="309a7-146">作为第一个实现，可以使用以下代码修复此问题：</span><span class="sxs-lookup"><span data-stu-id="309a7-146">As a first implementation, you could fix it with the following code:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="SecondImplementation":::

<span data-ttu-id="309a7-147">测试通过。</span><span class="sxs-lookup"><span data-stu-id="309a7-147">Your tests pass.</span></span> <span data-ttu-id="309a7-148">但是，添加的测试越多，要添加的 `if` 子句也越来越多，并要测试不同的属性。</span><span class="sxs-lookup"><span data-stu-id="309a7-148">But, as you add more tests, you'll add more and more `if` clauses and test different properties.</span></span> <span data-ttu-id="309a7-149">这些方法很快就会变得过于复杂，因为添加了更多的条件语句。</span><span class="sxs-lookup"><span data-stu-id="309a7-149">Soon, these methods will get too complicated as you add more conditionals.</span></span>

## <a name="implement-the-commands-with-patterns"></a><span data-ttu-id="309a7-150">使用模式实现命令</span><span class="sxs-lookup"><span data-stu-id="309a7-150">Implement the commands with patterns</span></span>

<span data-ttu-id="309a7-151">更好的方法是，使用模式确定对象是否处于可执行命令的有效状态。</span><span class="sxs-lookup"><span data-stu-id="309a7-151">A better way is to use *patterns* to determine if the object is in a valid state to execute a command.</span></span> <span data-ttu-id="309a7-152">可以表示是否允许将命令作为以下三个变量的函数：闸门状态、水位和新设置：</span><span class="sxs-lookup"><span data-stu-id="309a7-152">You can express if a command is allowed as a function of three variables: the state of the gate, the level of the water, and the new setting:</span></span>

| <span data-ttu-id="309a7-153">新设置</span><span class="sxs-lookup"><span data-stu-id="309a7-153">New setting</span></span> | <span data-ttu-id="309a7-154">闸门状态</span><span class="sxs-lookup"><span data-stu-id="309a7-154">Gate state</span></span> | <span data-ttu-id="309a7-155">水位</span><span class="sxs-lookup"><span data-stu-id="309a7-155">Water Level</span></span> | <span data-ttu-id="309a7-156">结果</span><span class="sxs-lookup"><span data-stu-id="309a7-156">Result</span></span>             |
| ----------- | ---------- | ----------- | ------------------ |
| <span data-ttu-id="309a7-157">关闭</span><span class="sxs-lookup"><span data-stu-id="309a7-157">Closed</span></span>      | <span data-ttu-id="309a7-158">关闭</span><span class="sxs-lookup"><span data-stu-id="309a7-158">Closed</span></span>     | <span data-ttu-id="309a7-159">高</span><span class="sxs-lookup"><span data-stu-id="309a7-159">High</span></span>        | <span data-ttu-id="309a7-160">关闭</span><span class="sxs-lookup"><span data-stu-id="309a7-160">Closed</span></span>             |
| <span data-ttu-id="309a7-161">关闭</span><span class="sxs-lookup"><span data-stu-id="309a7-161">Closed</span></span>      | <span data-ttu-id="309a7-162">关闭</span><span class="sxs-lookup"><span data-stu-id="309a7-162">Closed</span></span>     | <span data-ttu-id="309a7-163">低</span><span class="sxs-lookup"><span data-stu-id="309a7-163">Low</span></span>         | <span data-ttu-id="309a7-164">关闭</span><span class="sxs-lookup"><span data-stu-id="309a7-164">Closed</span></span>             |
| <span data-ttu-id="309a7-165">关闭</span><span class="sxs-lookup"><span data-stu-id="309a7-165">Closed</span></span>      | <span data-ttu-id="309a7-166">打开</span><span class="sxs-lookup"><span data-stu-id="309a7-166">Open</span></span>       | <span data-ttu-id="309a7-167">高</span><span class="sxs-lookup"><span data-stu-id="309a7-167">High</span></span>        | <span data-ttu-id="309a7-168">打开</span><span class="sxs-lookup"><span data-stu-id="309a7-168">Open</span></span>               |
| <span data-ttu-id="309a7-169">~~已解决~~</span><span class="sxs-lookup"><span data-stu-id="309a7-169">~~Closed~~</span></span>  | <span data-ttu-id="309a7-170">~~打开~~</span><span class="sxs-lookup"><span data-stu-id="309a7-170">~~Open~~</span></span>   | <span data-ttu-id="309a7-171">~~低~~</span><span class="sxs-lookup"><span data-stu-id="309a7-171">~~Low~~</span></span>     | <span data-ttu-id="309a7-172">~~已解决~~</span><span class="sxs-lookup"><span data-stu-id="309a7-172">~~Closed~~</span></span>         |
| <span data-ttu-id="309a7-173">打开</span><span class="sxs-lookup"><span data-stu-id="309a7-173">Open</span></span>        | <span data-ttu-id="309a7-174">已解决</span><span class="sxs-lookup"><span data-stu-id="309a7-174">Closed</span></span>     | <span data-ttu-id="309a7-175">高</span><span class="sxs-lookup"><span data-stu-id="309a7-175">High</span></span>        | <span data-ttu-id="309a7-176">打开</span><span class="sxs-lookup"><span data-stu-id="309a7-176">Open</span></span>               |
| <span data-ttu-id="309a7-177">打开</span><span class="sxs-lookup"><span data-stu-id="309a7-177">Open</span></span>        | <span data-ttu-id="309a7-178">已解决</span><span class="sxs-lookup"><span data-stu-id="309a7-178">Closed</span></span>     | <span data-ttu-id="309a7-179">低</span><span class="sxs-lookup"><span data-stu-id="309a7-179">Low</span></span>         | <span data-ttu-id="309a7-180">关闭（错误）</span><span class="sxs-lookup"><span data-stu-id="309a7-180">Closed (Error)</span></span>     |
| <span data-ttu-id="309a7-181">打开</span><span class="sxs-lookup"><span data-stu-id="309a7-181">Open</span></span>        | <span data-ttu-id="309a7-182">打开</span><span class="sxs-lookup"><span data-stu-id="309a7-182">Open</span></span>       | <span data-ttu-id="309a7-183">高</span><span class="sxs-lookup"><span data-stu-id="309a7-183">High</span></span>        | <span data-ttu-id="309a7-184">打开</span><span class="sxs-lookup"><span data-stu-id="309a7-184">Open</span></span>               |
| <span data-ttu-id="309a7-185">~~打开~~</span><span class="sxs-lookup"><span data-stu-id="309a7-185">~~Open~~</span></span>    | <span data-ttu-id="309a7-186">~~打开~~</span><span class="sxs-lookup"><span data-stu-id="309a7-186">~~Open~~</span></span>   | <span data-ttu-id="309a7-187">~~低~~</span><span class="sxs-lookup"><span data-stu-id="309a7-187">~~Low~~</span></span>     | <span data-ttu-id="309a7-188">~~关闭（错误）~~</span><span class="sxs-lookup"><span data-stu-id="309a7-188">~~Closed (Error)~~</span></span> |

<span data-ttu-id="309a7-189">表中的第四行和最后一行包含带删除线的文本，因为这些文本无效。</span><span class="sxs-lookup"><span data-stu-id="309a7-189">The fourth and last rows in the table have strike through text because they're invalid.</span></span> <span data-ttu-id="309a7-190">现在，要添加的代码应确保上闸门永远不会在水位低时打开。</span><span class="sxs-lookup"><span data-stu-id="309a7-190">The code you're adding now should make sure the high water gate is never opened when the water is low.</span></span>  <span data-ttu-id="309a7-191">可以将这些状态编码为单个开关表达式（请牢记 `false` 表示“关闭”）：</span><span class="sxs-lookup"><span data-stu-id="309a7-191">Those states can be coded as a single switch expression (remember that `false` indicates "Closed"):</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="ThirdImplementation":::

<span data-ttu-id="309a7-192">试用此版本。</span><span class="sxs-lookup"><span data-stu-id="309a7-192">Try this version.</span></span> <span data-ttu-id="309a7-193">验证代码时测试通过。</span><span class="sxs-lookup"><span data-stu-id="309a7-193">Your tests pass, validating the code.</span></span> <span data-ttu-id="309a7-194">完整的表格显示了输入与结果的可能组合方式。</span><span class="sxs-lookup"><span data-stu-id="309a7-194">The full table shows the possible combinations of inputs and results.</span></span> <span data-ttu-id="309a7-195">这意味着，你和其他开发人员可以快速查看此表，确保已包含所有可能的输入。</span><span class="sxs-lookup"><span data-stu-id="309a7-195">That means you and other developers can quickly look at the table and see that you've covered all the possible inputs.</span></span> <span data-ttu-id="309a7-196">也可以使用编译器来帮助实现这一目的，这样更为简单。</span><span class="sxs-lookup"><span data-stu-id="309a7-196">Even easier, the compiler can help as well.</span></span> <span data-ttu-id="309a7-197">添加前面的代码后，可以看到编译器生成以下警告：CS8524 表示开关表达式未包含所有可能的输入。</span><span class="sxs-lookup"><span data-stu-id="309a7-197">After you add the previous code, you can see that the compiler generates a warning: *CS8524* indicates the switch expression doesn't cover all possible inputs.</span></span> <span data-ttu-id="309a7-198">出现该警告的原因是，某个输入为 `enum` 类型。</span><span class="sxs-lookup"><span data-stu-id="309a7-198">The reason for that warning is that one of the inputs is an `enum` type.</span></span> <span data-ttu-id="309a7-199">编译器会将“所有可能的输入”解释为基础类型的所有输入，此类型通常为 `int`。</span><span class="sxs-lookup"><span data-stu-id="309a7-199">The compiler interprets "all possible inputs" as all inputs from the underlying type, typically an `int`.</span></span> <span data-ttu-id="309a7-200">此 `switch` 表达式仅检查 `enum` 中声明的值。</span><span class="sxs-lookup"><span data-stu-id="309a7-200">This `switch` expression only checks the values declared in the `enum`.</span></span> <span data-ttu-id="309a7-201">若要删除此警告，可以为表达式的最后一个分支添加全部捕获弃用模式。</span><span class="sxs-lookup"><span data-stu-id="309a7-201">To remove the warning, you can add a catch-all discard pattern for the last arm of the expression.</span></span> <span data-ttu-id="309a7-202">此条件会引发异常，因为它表示输入无效：</span><span class="sxs-lookup"><span data-stu-id="309a7-202">This condition throws an exception, because it indicates invalid input:</span></span>

```csharp
_  => throw new InvalidOperationException("Invalid internal state"),
```

<span data-ttu-id="309a7-203">前面的开关分支必须是 `switch` 表达式中的最后一个，因为它与所有输入匹配。</span><span class="sxs-lookup"><span data-stu-id="309a7-203">The preceding switch arm must be last in your `switch` expression because it matches all inputs.</span></span> <span data-ttu-id="309a7-204">通过将它移到序列的较前方进行试验。</span><span class="sxs-lookup"><span data-stu-id="309a7-204">Experiment by moving it earlier in the order.</span></span> <span data-ttu-id="309a7-205">这将引发编译器错误 CS8510，因为模式中的代码无法访问。</span><span class="sxs-lookup"><span data-stu-id="309a7-205">That causes a compiler error *CS8510* for unreachable code in a pattern.</span></span>  <span data-ttu-id="309a7-206">开关表达式本身的结构允许编译器针对可能的错误生成错误和警告。</span><span class="sxs-lookup"><span data-stu-id="309a7-206">The natural structure of switch expressions enables the compiler to generate errors and warnings for possible mistakes.</span></span> <span data-ttu-id="309a7-207">借助编译器“安全网格”，可以通过较少的迭代更轻松地生成正确的代码，并可以自由地将开关分支与通配符组合在一起。</span><span class="sxs-lookup"><span data-stu-id="309a7-207">The compiler "safety net" makes it easier for you to create correct code in fewer iterations, and the freedom to combine switch arms with wildcards.</span></span> <span data-ttu-id="309a7-208">如果组合生成了意外的不可访问的分支，编译器将发出错误，如果删除了所需的分支，它将发出警告。</span><span class="sxs-lookup"><span data-stu-id="309a7-208">The compiler will issue errors if your combination results in unreachable arms you didn't expect, and warnings if you remove an arm that's needed.</span></span>

<span data-ttu-id="309a7-209">第一个更改用于组合命令为关闭闸门的所有分支；这是始终允许的。</span><span class="sxs-lookup"><span data-stu-id="309a7-209">The first change is to combine all the arms where the command is to close the gate; that's always allowed.</span></span> <span data-ttu-id="309a7-210">将以下代码添加为开关表达式中的第一个分支：</span><span class="sxs-lookup"><span data-stu-id="309a7-210">Add the following code as the first arm in your switch expression:</span></span>

```csharp
(false, _, _) => false,
```

<span data-ttu-id="309a7-211">添加前面的开关分支后，将收到四个编译器错误，每个命令为 `false` 的分支都有一个错误。</span><span class="sxs-lookup"><span data-stu-id="309a7-211">After you add the previous switch arm, you'll get four compiler errors, one on each of the arms where the command is `false`.</span></span> <span data-ttu-id="309a7-212">新添加的分支已包含这些分支。</span><span class="sxs-lookup"><span data-stu-id="309a7-212">Those arms are already covered by the newly added arm.</span></span> <span data-ttu-id="309a7-213">可以放心地删除这四行。</span><span class="sxs-lookup"><span data-stu-id="309a7-213">You can safely remove those four lines.</span></span> <span data-ttu-id="309a7-214">你计划使用这个新的开关分支替换这些条件。</span><span class="sxs-lookup"><span data-stu-id="309a7-214">You intended this new switch arm to replace those conditions.</span></span>

<span data-ttu-id="309a7-215">接下来，可以简化命令为打开闸门的四个分支。</span><span class="sxs-lookup"><span data-stu-id="309a7-215">Next, you can simplify the four arms where the command is to open the gate.</span></span> <span data-ttu-id="309a7-216">在水位较高的两种情况下，闸门可以打开。</span><span class="sxs-lookup"><span data-stu-id="309a7-216">In both cases where the water level is high, the gate can be opened.</span></span> <span data-ttu-id="309a7-217">（在其中一种情况下，闸门已打开。）一种水位较低的情况将引发异常，另一种情况不应发生。</span><span class="sxs-lookup"><span data-stu-id="309a7-217">(In one, it's already open.) One case where the water level is low throws an exception, and the other shouldn't happen.</span></span> <span data-ttu-id="309a7-218">如果水闸已处于无效状态，引发同样的异常应是安全的。</span><span class="sxs-lookup"><span data-stu-id="309a7-218">It should be safe to throw the same exception if the water lock is already in an invalid state.</span></span> <span data-ttu-id="309a7-219">可以对这些分支进行以下简化：</span><span class="sxs-lookup"><span data-stu-id="309a7-219">You can make the following simplifications for those arms:</span></span>

```csharp
(true, _, WaterLevel.High) => true,
(true, false, WaterLevel.Low) => throw new InvalidOperationException("Cannot open high gate when the water is low"),
_ => throw new InvalidOperationException("Invalid internal state"),
```

<span data-ttu-id="309a7-220">重新运行测试，测试通过。</span><span class="sxs-lookup"><span data-stu-id="309a7-220">Run your tests again, and they pass.</span></span> <span data-ttu-id="309a7-221">以下是 `SetHighGate` 方法的最终版本：</span><span class="sxs-lookup"><span data-stu-id="309a7-221">Here's the final version of the `SetHighGate` method:</span></span>

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalImplementaton":::

## <a name="implement-patterns-yourself"></a><span data-ttu-id="309a7-222">自行实现模式</span><span class="sxs-lookup"><span data-stu-id="309a7-222">Implement patterns yourself</span></span>

<span data-ttu-id="309a7-223">现在你已了解了此技巧，接下来请自行填写 `SetLowGate` 和 `SetWaterLevel` 方法。</span><span class="sxs-lookup"><span data-stu-id="309a7-223">Now that you've seen the technique, fill in the `SetLowGate` and `SetWaterLevel` methods yourself.</span></span>  <span data-ttu-id="309a7-224">首先，添加以下代码来测试这些方法上的无效操作：</span><span class="sxs-lookup"><span data-stu-id="309a7-224">Start by adding the following code to test invalid operations on those methods:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="FinalTestCode":::

<span data-ttu-id="309a7-225">重新运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="309a7-225">Run your application again.</span></span> <span data-ttu-id="309a7-226">可以看到新的测试失败，运河闸进入无效状态。</span><span class="sxs-lookup"><span data-stu-id="309a7-226">You can see the new tests fail, and the canal lock gets into an invalid state.</span></span> <span data-ttu-id="309a7-227">尝试自行实现剩余的方法。</span><span class="sxs-lookup"><span data-stu-id="309a7-227">Try to implement the remaining methods yourself.</span></span> <span data-ttu-id="309a7-228">用于设置下闸门的方法应类似于用于设置上闸门的方法。</span><span class="sxs-lookup"><span data-stu-id="309a7-228">The method to set the lower gate should be similar to the method to set the upper gate.</span></span> <span data-ttu-id="309a7-229">用于更改水位的方法包含不同的检查，但应采用相似的结构。</span><span class="sxs-lookup"><span data-stu-id="309a7-229">The method that changes the water level has different checks, but should follow a similar structure.</span></span> <span data-ttu-id="309a7-230">将同一过程用于设置水位的方法，你会发现这样很有用。</span><span class="sxs-lookup"><span data-stu-id="309a7-230">You may find it helpful to use the same process for the method that sets the water level.</span></span> <span data-ttu-id="309a7-231">从所有的四个输入开始：两个闸门的状态、水位的当前状态和请求的新水位。</span><span class="sxs-lookup"><span data-stu-id="309a7-231">Start with all four inputs: The state of both gates, the current state of the water level, and the requested new water level.</span></span> <span data-ttu-id="309a7-232">开关表达式应以下列形式开头：</span><span class="sxs-lookup"><span data-stu-id="309a7-232">The switch expression should start with:</span></span>

```csharp
CanalLockWaterLevel = (newLevel, CanalLockWaterLevel, LowWaterGateOpen, HighWaterGateOpen) switch
{
    // elided
};
```

<span data-ttu-id="309a7-233">要填写 16 个总开关分支。</span><span class="sxs-lookup"><span data-stu-id="309a7-233">You'll have 16 total switch arms to fill in.</span></span> <span data-ttu-id="309a7-234">然后进行测试和简化。</span><span class="sxs-lookup"><span data-stu-id="309a7-234">Then, test and simplify.</span></span>

<span data-ttu-id="309a7-235">你生成的方法与此类似吗？</span><span class="sxs-lookup"><span data-stu-id="309a7-235">Did you make methods something like this?</span></span>

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalExercise":::

<span data-ttu-id="309a7-236">你的测试应该可以通过，并且运河闸应安全运转。</span><span class="sxs-lookup"><span data-stu-id="309a7-236">Your tests should pass, and the canal lock should operate safely.</span></span>

## <a name="summary"></a><span data-ttu-id="309a7-237">总结</span><span class="sxs-lookup"><span data-stu-id="309a7-237">Summary</span></span>

<span data-ttu-id="309a7-238">在本教程中，你学习了：在对对象的内部状态应用任何更改前，如何使用模式匹配检查该状态。</span><span class="sxs-lookup"><span data-stu-id="309a7-238">In this tutorial, you learned to use pattern matching to check the internal state of an object before applying any changes to that state.</span></span> <span data-ttu-id="309a7-239">你可以检查属性组合。</span><span class="sxs-lookup"><span data-stu-id="309a7-239">You can check combinations of properties.</span></span> <span data-ttu-id="309a7-240">针对其中任意一种转换生成表格后，测试代码，然后进行简化实现可读性和可维护性。</span><span class="sxs-lookup"><span data-stu-id="309a7-240">Once you've built tables for any of those transitions, you test your code, then simplify for readability and maintainability.</span></span> <span data-ttu-id="309a7-241">这些初步的重构可能会表明需要进一步重构，以验证内部状态或管理其他 API 更改。</span><span class="sxs-lookup"><span data-stu-id="309a7-241">These initial refactorings may suggest further refactorings that validate internal state or manage other API changes.</span></span> <span data-ttu-id="309a7-242">本教程结合使用了类和对象与更加面向数据的基于模式的方法，来实现这些类。</span><span class="sxs-lookup"><span data-stu-id="309a7-242">This tutorial combined classes and objects with a more data-oriented, pattern-based approach to implement those classes.</span></span>
